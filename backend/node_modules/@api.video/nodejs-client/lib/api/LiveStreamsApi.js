"use strict";
/**
 * @api.video/nodejs-client
 * api.video is an API that encodes on the go to facilitate immediate playback, enhancing viewer streaming experiences across multiple devices and platforms. You can stream live or on-demand online videos within minutes.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated.
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const url_1 = require("url");
const form_data_1 = __importDefault(require("form-data"));
const ObjectSerializer_1 = __importDefault(require("../ObjectSerializer"));
const stream_1 = require("stream");
const HttpClient_1 = require("../HttpClient");
/**
 * no description
 */
class LiveStreamsApi {
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    /**
     * Creates a livestream object.
     * Create live stream
     * @param liveStreamCreationPayload
     */
    async create(liveStreamCreationPayload) {
        const queryParams = {};
        queryParams.headers = {};
        if (liveStreamCreationPayload === null ||
            liveStreamCreationPayload === undefined) {
            throw new Error('Required parameter liveStreamCreationPayload was null or undefined when calling create.');
        }
        // Path Params
        const localVarPath = '/live-streams'.substring(1);
        // Body Params
        const contentType = ObjectSerializer_1.default.getPreferredMediaType([
            'application/json',
        ]);
        queryParams.headers['Content-Type'] = contentType;
        queryParams.body = ObjectSerializer_1.default.stringify(ObjectSerializer_1.default.serialize(liveStreamCreationPayload, 'LiveStreamCreationPayload', ''), contentType);
        queryParams.method = 'POST';
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'LiveStream', ''));
    }
    /**
     * Get a livestream by id.
     * Retrieve live stream
     * @param liveStreamId The unique ID for the live stream you want to watch.
     */
    async get(liveStreamId) {
        const queryParams = {};
        queryParams.headers = {};
        if (liveStreamId === null || liveStreamId === undefined) {
            throw new Error('Required parameter liveStreamId was null or undefined when calling get.');
        }
        // Path Params
        const localVarPath = '/live-streams/{liveStreamId}'
            .substring(1)
            .replace('{' + 'liveStreamId' + '}', encodeURIComponent(String(liveStreamId)));
        queryParams.method = 'GET';
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'LiveStream', ''));
    }
    /**
     * Updates the livestream object.
     * Update a live stream
     * @param liveStreamId The unique ID for the live stream that you want to update information for such as player details, or whether you want the recording on or off.
     * @param liveStreamUpdatePayload
     */
    async update(liveStreamId, liveStreamUpdatePayload = {}) {
        const queryParams = {};
        queryParams.headers = {};
        if (liveStreamId === null || liveStreamId === undefined) {
            throw new Error('Required parameter liveStreamId was null or undefined when calling update.');
        }
        if (liveStreamUpdatePayload === null ||
            liveStreamUpdatePayload === undefined) {
            throw new Error('Required parameter liveStreamUpdatePayload was null or undefined when calling update.');
        }
        // Path Params
        const localVarPath = '/live-streams/{liveStreamId}'
            .substring(1)
            .replace('{' + 'liveStreamId' + '}', encodeURIComponent(String(liveStreamId)));
        // Body Params
        const contentType = ObjectSerializer_1.default.getPreferredMediaType([
            'application/json',
        ]);
        queryParams.headers['Content-Type'] = contentType;
        queryParams.body = ObjectSerializer_1.default.stringify(ObjectSerializer_1.default.serialize(liveStreamUpdatePayload, 'LiveStreamUpdatePayload', ''), contentType);
        queryParams.method = 'PATCH';
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'LiveStream', ''));
    }
    /**
     * If you do not need a live stream any longer, you can send a request to delete it. All you need is the liveStreamId.
     * Delete a live stream
     * @param liveStreamId The unique ID for the live stream that you want to remove.
     */
    async delete(liveStreamId) {
        const queryParams = {};
        queryParams.headers = {};
        if (liveStreamId === null || liveStreamId === undefined) {
            throw new Error('Required parameter liveStreamId was null or undefined when calling delete.');
        }
        // Path Params
        const localVarPath = '/live-streams/{liveStreamId}'
            .substring(1)
            .replace('{' + 'liveStreamId' + '}', encodeURIComponent(String(liveStreamId)));
        queryParams.method = 'DELETE';
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'void', ''));
    }
    /**
     * Get the list of livestreams on the workspace.
     * List all live streams
     * @param {Object} searchParams
     * @param { string } searchParams.streamKey The unique stream key that allows you to stream videos.
     * @param { string } searchParams.name You can filter live streams by their name or a part of their name.
     * @param { string } searchParams.sortBy Allowed: createdAt, publishedAt, name. createdAt - the time a livestream was created using the specified streamKey. publishedAt - the time a livestream was published using the specified streamKey. name - the name of the livestream. If you choose one of the time based options, the time is presented in ISO-8601 format.
     * @param { &#39;asc&#39; | &#39;desc&#39; } searchParams.sortOrder Allowed: asc, desc. Ascending for date and time means that earlier values precede later ones. Descending means that later values preced earlier ones. For title, it is 0-9 and A-Z ascending and Z-A, 9-0 descending.
     * @param { number } searchParams.currentPage Choose the number of search results to return per page. Minimum value: 1
     * @param { number } searchParams.pageSize Results per page. Allowed values 1-100, default is 25.
     */
    async list({ streamKey, name, sortBy, sortOrder, currentPage, pageSize, } = {}) {
        const queryParams = {};
        queryParams.headers = {};
        // Path Params
        const localVarPath = '/live-streams'.substring(1);
        // Query Params
        const urlSearchParams = new url_1.URLSearchParams();
        if (streamKey !== undefined) {
            urlSearchParams.append('streamKey', ObjectSerializer_1.default.serialize(streamKey, 'string', ''));
        }
        if (name !== undefined) {
            urlSearchParams.append('name', ObjectSerializer_1.default.serialize(name, 'string', ''));
        }
        if (sortBy !== undefined) {
            urlSearchParams.append('sortBy', ObjectSerializer_1.default.serialize(sortBy, 'string', ''));
        }
        if (sortOrder !== undefined) {
            urlSearchParams.append('sortOrder', ObjectSerializer_1.default.serialize(sortOrder, "'asc' | 'desc'", ''));
        }
        if (currentPage !== undefined) {
            urlSearchParams.append('currentPage', ObjectSerializer_1.default.serialize(currentPage, 'number', ''));
        }
        if (pageSize !== undefined) {
            urlSearchParams.append('pageSize', ObjectSerializer_1.default.serialize(pageSize, 'number', ''));
        }
        queryParams.searchParams = urlSearchParams;
        queryParams.method = 'GET';
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'LiveStreamListResponse', ''));
    }
    /**
     * Upload the thumbnail for the livestream.
     * Upload a thumbnail
     * @param liveStreamId The unique ID for the live stream you want to upload.
     * @param file The image to be added as a thumbnail. The mime type should be image/jpeg, image/png or image/webp. The max allowed size is 8 MiB.
     */
    async uploadThumbnail(liveStreamId, file) {
        const queryParams = {};
        queryParams.headers = {};
        if (liveStreamId === null || liveStreamId === undefined) {
            throw new Error('Required parameter liveStreamId was null or undefined when calling uploadThumbnail.');
        }
        let fileName = 'file';
        let fileBuffer = file;
        if (typeof file === 'string') {
            fileName = path_1.default.basename(file);
            fileBuffer = (0, fs_1.createReadStream)(file);
        }
        if (file instanceof stream_1.Readable) {
            fileBuffer = await (0, HttpClient_1.readableToBuffer)(file);
        }
        // Path Params
        const localVarPath = '/live-streams/{liveStreamId}/thumbnail'
            .substring(1)
            .replace('{' + 'liveStreamId' + '}', encodeURIComponent(String(liveStreamId)));
        queryParams.method = 'POST';
        const formData = new form_data_1.default();
        formData.append(fileName, fileBuffer, fileName);
        queryParams.body = formData;
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'LiveStream', ''));
    }
    /**
     * Send the unique identifier for a live stream to delete its thumbnail.
     * Delete a thumbnail
     * @param liveStreamId The unique identifier of the live stream whose thumbnail you want to delete.
     */
    async deleteThumbnail(liveStreamId) {
        const queryParams = {};
        queryParams.headers = {};
        if (liveStreamId === null || liveStreamId === undefined) {
            throw new Error('Required parameter liveStreamId was null or undefined when calling deleteThumbnail.');
        }
        // Path Params
        const localVarPath = '/live-streams/{liveStreamId}/thumbnail'
            .substring(1)
            .replace('{' + 'liveStreamId' + '}', encodeURIComponent(String(liveStreamId)));
        queryParams.method = 'DELETE';
        return this.httpClient
            .call(localVarPath, queryParams)
            .then((response) => ObjectSerializer_1.default.deserialize(ObjectSerializer_1.default.parse(response.body, response.headers['content-type']), 'LiveStream', ''));
    }
}
exports.default = LiveStreamsApi;
